#!/usr/bin/env python
"""
malware_grouping_simulator.py

Created by Youngsang Shin on 2015-11-03.
Last Modified by Youngsang Shin on 2015-11-03.

Copyright (c) 2015 Korea Internet & Security Agency. All rights reserved.
"""

import sys
import getopt
import json
import sqlite3
import pprint
import sqlite3
#import networkx
from os import listdir
from os.path import isfile, join


__author__ = 'Youngsang Shin'

help_message = '''
The help message goes here.
'''

#
# default parameters
#
config_filename = "config.json"
verbose = False

similarity_DB = {}

class Usage(Exception):
    def __init__(self, msg):
        self.msg = msg


def grouping_by_all_members(similarity_db_cursor, group, malware_hash, similarity_threshold):
    group_assignment_flag = False
    for group_id in group.keys():
        group_in_flag = True

        #
        # The below algorithm:
        #
        # currently, only when the similarity values w.r.t all of the members in a group
        # are greater than or equal to THRESHOLD, the new malware is added to the group
        #
        for member_malware_hash in group[group_id]:
            similarity_db_cursor.execute('SELECT similarity_val FROM similarity WHERE src_filehash=:src_filehash and dst_filehash=:dst_filehash', \
                       {"src_filehash":malware_hash, "dst_filehash":member_malware_hash})
            similarity_value_list = similarity_db_cursor.fetchall()

            for similarity_value in similarity_value_list[0]:
                sim_val = float(unicode(similarity_value).encode('ascii'))
                if sim_val < similarity_threshold:
                    group_in_flag = False
                    break

            if group_in_flag == False:
                break

        if group_in_flag == True:
            group[group_id].append(malware_hash)
            group_assignment_flag = True

    return group_assignment_flag


def select_sample_members(group_member_list, sample_member_selection_method):
    sample_member_malware_hash_list = group_memeber_list

    if sampel_memeber_selection_method == None:
        sample_member_malware_hash_list = group_memeber_list

    return sample_member_malware_hash_list

def grouping_by_sample_members(similarity_db_cursor, group, malware_hash, similarity_threshold, sample_member_selection_method):
    group_assignment_flag = False
    for group_id in group.keys():
        group_in_flag = True

        #
        # The below algorithm:
        #
        # currently, only when the similarity values w.r.t all of the members in a group
        # are greater than or equal to THRESHOLD, the new malware is added to the group
        #
        sample_member_malware_hash_list = select_sample_members(group[group_id], sample_member_selection_method)

        for member_malware_hash in sample_member_malware_hash_list:
            similarity_db_cursor.execute('SELECT similarity_val FROM similarity WHERE src_filehash=:src_filehash and dst_filehash=:dst_filehash', \
                       {"src_filehash":malware_hash, "dst_filehash":member_malware_hash})
            similarity_value_list = similarity_db_cursor.fetchall()

            for similarity_value in similarity_value_list[0]:
                sim_val = float(unicode(similarity_value).encode('ascii'))
                if sim_val < similarity_threshold:
                    group_in_flag = False
                    break

            if group_in_flag == False:
                break

        if group_in_flag == True:
            group[group_id].append(malware_hash)
            group_assignment_flag = True

    return group_assignment_flag


def group_filtering():
    print ""


#--------------------------------------------------------------
# Performs sequential grouping
#--------------------------------------------------------------
#
# sample_member_selection_method : None or ...
# filtering_method : None or ....
#
def sequential_grouping(in_malware_filename, similarity_db_filename, similarity_threshold, \
                        sample_member_selection_method, filtering_method):

    #
    # group info
    new_group_id = 0 # new group id which needs to be assigned
    group = {}

    # connect to DB
    conn = sqlite3.connect(similarity_db_filename)
    similarity_db_cursor = conn.cursor()

    #
    # read malware hash codes
    malware_hash_file = open(in_malware_filename, "r")
    for malware_hash in malware_hash_file:
        malware_hash = malware_hash[:-1]
        #print new_group_id, malware_hash

        #
        # grouping algorithm
        if new_group_id == 0: # there is no existing group at all
            group[new_group_id] = [malware_hash]
            new_group_id += 1
        else:
            if (sample_member_selection_method == None):
                group_assignment_flag = grouping_by_all_members(similarity_db_cursor, group, malware_hash, similarity_threshold)

            #
            # in case that the malware is not assigned into any group
            if group_assignment_flag == False: # new group needs to be created
                group[new_group_id] = [malware_hash]
                new_group_id += 1

    # close DB
    conn.close()
    malware_hash_file.close()

    return group

#
# Analyzes the characteristics of the groups
#
def analysis_group(group):

    for group_id in group.keys():
        print group_id, ":", len(group[group_id])


#
# sequential grouping without any periodic filtering
#
def test_driver1(config_filename):
    print "*********************************************************************"
    print "** Test Driver 1 : Sequential Grouping without Periodic Filtering"
    print "**-----------------------------------------------------------------**"
    config_json = open(config_filename, 'r').read()
    config = json.loads(config_json)
    in_malware_filename = unicode(config["test1"]["in_malware_filename"]).encode('ascii')
    similarity_db_filename = unicode(config["test1"]["similarity_db_filename"]).encode('ascii')
    similarity_threshold = float(unicode(config["test1"]["similarity_threshold"]).encode('ascii'))

    print "in_malware_filename :", in_malware_filename
    print "similarity_db_filename :", similarity_db_filename
    print "similarity_threshold :", similarity_threshold
    print "*********************************************************************"

    #
    # grouping
    group = sequential_grouping(in_malware_filename, similarity_db_filename, similarity_threshold, \
                                None, None)

    #
    # analysis of the result
    analysis_group(group)


#
# sequential grouping with periodic filterings
#
def test_driver2():
    print "*********************************************************************"
    print "** Test Driver 2 : Sequential Grouping with Periodic Filtering"
    print "**-----------------------------------------------------------------**"
    config_json = open(config_filename, 'r').read()
    config = json.loads(config_json)
    in_malware_filename = unicode(config["test1"]["in_malware_filename"]).encode('ascii')
    similarity_db_filename = unicode(config["test1"]["similarity_db_filename"]).encode('ascii')
    similarity_threshold = float(unicode(config["test1"]["similarity_threshold"]).encode('ascii'))

    print "in_malware_filename :", in_malware_filename
    print "similarity_db_filename :", similarity_db_filename
    print "similarity_threshold :", similarity_threshold
    print "*********************************************************************"

    #
    # grouping
    group = sequential_grouping(in_malware_filename, similarity_db_filename, similarity_threshold, \
                                None, None)

    #
    # analysis of the result
    analysis_group(group)


def main(argv=None):

    #
    # default parameters
    #
    config_filename = "config.json"
    data_path = "./data/sample1/"
    verbose = False
    driver = 1
    filename_type = 1
    db_threshold = 0.9

    if argv is None:
        argv = sys.argv
    try:
        try:
            opts, args = getopt.getopt(argv[1:], "hcd:v",
                ["help", "config=", "driver="])
        except getopt.error, msg:
            raise Usage(msg)

        # option processing
        for option, value in opts:
            if option == "-v":
                verbose = True
            if option in ("-h", "--help"):
                raise Usage(help_message)
            if option in ("-c", "--config"):
                config_filename = value
            if option in ("-d", "--driver"):
                driver = value

        #
        # display the parameters for the simulation
        print "************ parameters for the simulation ************"
        print "verbose =", verbose
        print "configfile =", config_filename
        print "driver =", driver
        print "*******************************************************"

        if driver == 1:
            test_driver1(config_filename)
        elif driver == 2:
            test_driver2()
        else:
            print "Wrong Option for Test Driver!"


    except Usage, err:
        print >> sys.stderr, sys.argv[0].split("/")[-1] + ": " + str(err.msg)
        print >> sys.stderr, "\t for help use --help"
        return 2

#
# runs this script
if __name__ == "__main__":
    sys.exit(main())
